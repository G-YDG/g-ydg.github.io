<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,minimal-ui"><meta name="renderer" content="webkit"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=no,email=no,adress=no"><meta name="theme-color" content="#000000"><meta http-equiv="window-target" content="_top"><title>常见代码重构技巧 | YddBlog</title><meta name="description" content="关于重构为什么要重构 项目在不断演进过程中，代码不停地在堆砌。如果没有人为代码的质量负责，代码总是会往越来越混乱的方向演进。当混乱到一定程度之后，量变引起质变，项目的维护成本已经高过重新开发一套新代码的成本，想要再去重构，已经没有人能做到了。 造成这样的原因往往有以下几点：  编码之前缺乏有效的设计 成本上的考虑，在原功能堆砌式编程 缺乏有效代码质量监督机制  对于此类问题，业界已有有很好的解决思"><meta property="og:type" content="article"><meta property="og:title" content="常见代码重构技巧"><meta property="og:url" content="https://g-ydg.github.io/2021/05/18/%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84%E6%8A%80%E5%B7%A7/index.html"><meta property="og:site_name" content="ydd"><meta property="og:description" content="关于重构为什么要重构 项目在不断演进过程中，代码不停地在堆砌。如果没有人为代码的质量负责，代码总是会往越来越混乱的方向演进。当混乱到一定程度之后，量变引起质变，项目的维护成本已经高过重新开发一套新代码的成本，想要再去重构，已经没有人能做到了。 造成这样的原因往往有以下几点：  编码之前缺乏有效的设计 成本上的考虑，在原功能堆砌式编程 缺乏有效代码质量监督机制  对于此类问题，业界已有有很好的解决思"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/g-ydg/images/blog/Fv529wgo-IG_irUaeSvt4uXsou0r.jpeg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/g-ydg/images/blog/FqZ2t7CbF2JTYVct7X3Ly0Ju8ByJ.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/g-ydg/images/blog/Fsx644dZvzId3kuGl5Ltm154V7FK.jpeg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/g-ydg/images/blog/FgDcHDOP9zogfhRMtAdbz2etc-n7.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/g-ydg/images/blog/FhoEpGQYbmtY_ILLjLa87JOmBWTz.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/g-ydg/images/blog/FoQjsDq7p3AB0a7bLgGkEFYB_IQv.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/g-ydg/images/blog/FibrgbZ4-qXo962kPEWWAFx7eE78.png"><meta property="article:published_time" content="2021-05-18T00:11:47.000Z"><meta property="article:modified_time" content="2026-02-22T02:08:14.840Z"><meta property="article:author" content="Ydd"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/g-ydg/images/blog/Fv529wgo-IG_irUaeSvt4uXsou0r.jpeg"><link rel="canonical" href="https://g-ydg.github.io/2021/05/18/%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84%E6%8A%80%E5%B7%A7/index.html"><link rel="alternate" href="/atom.xml" title="ydd" type="application/atom+xml"><link rel="icon" href="/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 5.4.2"></head><body class="main-center theme-purple" itemscope itemtype="http://schema.org/WebPage"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="slimContent"><div class="navbar-header"><div class="search" id="search-form-wrap"><form class="search-form sidebar-form"><div class="input-group"><input type="text" class="search-form-input form-control" placeholder="搜索"> <span class="input-group-btn"><button type="submit" class="search-form-submit btn btn-flat" onclick="return!1"><i class="icon icon-search"></i></button></span></div></form><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"><input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech> <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div></div><button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button></div><nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation"><ul class="nav navbar-nav main-nav menu-highlight"><li class="menu-item menu-item-home"><a href="/."><i class="icon icon-home-fill"></i> <span class="menu-title">首页</span></a></li><li class="menu-item menu-item-archives"><a href="/archives"><i class="icon icon-archives-fill"></i> <span class="menu-title">归档</span></a></li><li class="menu-item menu-item-repository"><a href="/repository"><i class="icon icon-project"></i> <span class="menu-title">项目</span></a></li></ul><ul class="social-links"><li><a href="https://github.com/g-ydg" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li><li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li></ul></nav></div></header><aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar"><div class="slimContent"><div class="widget"><h3 class="widget-title">公告</h3><div class="widget-body"><div id="board"><div class="content"><p>欢迎交流与分享经验!</p></div></div></div></div><div class="widget"><h3 class="widget-title">归档</h3><div class="widget-body"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">十一月 2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">九月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">五月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">四月 2023</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">三月 2023</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">二月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">十二月 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">十一月 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">十月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">九月 2022</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">八月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">七月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">五月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">三月 2022</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">二月 2022</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">一月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">十二月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">十一月 2021</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">十月 2021</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">九月 2021</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">八月 2021</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a><span class="archive-list-count">5</span></li></ul></div></div><div class="widget"><h3 class="widget-title">最新文章</h3><div class="widget-body"><ul class="recent-post-list list-unstyled no-thumbnail"><li><div class="item-inner"><p class="item-category"></p><p class="item-title"><a href="/2024/11/06/Docker%E6%97%A5%E5%BF%97%E6%B8%85%E7%90%86/" class="title">Docker日志清理</a></p><p class="item-date"><time datetime="2024-11-06T19:54:22.000Z" itemprop="datePublished">2024-11-07</time></p></div></li><li><div class="item-inner"><p class="item-category"></p><p class="item-title"><a href="/2023/09/03/Wechaty+ChatGPT%20%E5%AE%9E%E7%8E%B0%E4%B8%AA%E4%BA%BA%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA/" class="title">Wechaty+ChatGPT 实现个人聊天机器人</a></p><p class="item-date"><time datetime="2023-09-03T22:32:07.000Z" itemprop="datePublished">2023-09-04</time></p></div></li><li><div class="item-inner"><p class="item-category"></p><p class="item-title"><a href="/2023/05/17/%E9%98%BF%E9%87%8C%E4%BA%91CLI/" class="title">阿里云CLI</a></p><p class="item-date"><time datetime="2023-05-17T22:49:05.000Z" itemprop="datePublished">2023-05-18</time></p></div></li><li><div class="item-inner"><p class="item-category"></p><p class="item-title"><a href="/2023/04/03/Kubernetes%20Tutorials%20%EF%BD%9C%20k8s%20%E6%95%99%E7%A8%8B/" class="title">Kubernetes Tutorials ｜ k8s 教程</a></p><p class="item-date"><time datetime="2023-04-03T18:13:01.000Z" itemprop="datePublished">2023-04-04</time></p></div></li><li><div class="item-inner"><p class="item-category"></p><p class="item-title"><a href="/2023/04/02/COS%20+%20Github%20Actions%20%E5%AE%9E%E7%8E%B0%E8%AF%AD%E9%9B%80%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/" class="title">COS + Github Actions 实现语雀自动发布</a></p><p class="item-date"><time datetime="2023-04-02T23:17:38.000Z" itemprop="datePublished">2023-04-03</time></p></div></li></ul></div></div></div></aside><main class="main" role="main"><div class="content"><article id="post-常见代码重构技巧" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting"><div class="article-header"><h1 class="article-title" itemprop="name">常见代码重构技巧</h1><div class="article-meta"><span class="article-date"><i class="icon icon-calendar-check"></i> <a href="/2021/05/18/%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84%E6%8A%80%E5%B7%A7/" class="article-date"><time datetime="2021-05-18T00:11:47.000Z" itemprop="datePublished">2021-05-18</time> </a></span><span class="article-read hidden-xs"><i class="icon icon-eye-fill" aria-hidden="true"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span> </span></span><span class="post-comment"><i class="icon icon-comment"></i> <a href="/2021/05/18/%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84%E6%8A%80%E5%B7%A7/#comments" class="article-comment-link">评论</a></span> <span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 12k(字)</span> <span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 44(分)</span></div></div><div class="article-entry marked-body" itemprop="articleBody"><h1 id="关于重构"><a href="#关于重构" class="headerlink" title="关于重构"></a>关于重构</h1><h2 id="为什么要重构"><a href="#为什么要重构" class="headerlink" title="为什么要重构"></a>为什么要重构</h2><p><img src="https://cdn.jsdelivr.net/gh/g-ydg/images/blog/Fv529wgo-IG_irUaeSvt4uXsou0r.jpeg"></p><p>项目在不断演进过程中，代码不停地在堆砌。如果没有人为代码的质量负责，代码总是会往越来越混乱的方向演进。当混乱到一定程度之后，量变引起质变，项目的维护成本已经高过重新开发一套新代码的成本，想要再去重构，已经没有人能做到了。</p><p>造成这样的原因往往有以下几点：</p><ol><li>编码之前缺乏有效的设计</li><li>成本上的考虑，在原功能堆砌式编程</li><li>缺乏有效代码质量监督机制</li></ol><p>对于此类问题，业界已有有很好的解决思路：通过持续不断的重构将代码中的“坏味道”清除掉。</p><h2 id="什么是重构"><a href="#什么是重构" class="headerlink" title="什么是重构"></a>什么是重构</h2><p>重构一书的作者 Martin Fowler 对重构的定义：</p><p>重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。重构（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。</p><p>根据重构的规模可以大致分为大型重构和小型重构：</p><p><strong>大型重构</strong>：对顶层代码设计的重构，包括：系统、模块、代码结构、类与类之间的关系等的重构，重构的手段有：分层、模块化、解耦、抽象可复用组件等等。这类重构的工具就是我们学习过的那些设计思想、原则和模式。这类重构涉及的代码改动会比较多，影响面会比较大，所以难度也较大，耗时会比较长，引入 bug 的风险也会相对比较大。</p><p><strong>小型重构</strong>：对代码细节的重构，主要是针对类、函数、变量等代码级别的重构，比如规范命名和注释、消除超大类或函数、提取重复代码等等。小型重构更多的是使用统一的编码规范。这类重构要修改的地方比较集中，比较简单，可操作性较强，耗时会比较短，引入 bug 的风险相对来说也会比较小。 对于小型重构，我们在新功能开发、修 bug 或者代码 review 中出现“代码坏味道”，我们就应该及时进行重构。持续在日常开发中进行小重构，能够降低重构和测试的成本。</p><h1 id="代码的坏味道"><a href="#代码的坏味道" class="headerlink" title="代码的坏味道"></a>代码的坏味道</h1><p><img src="https://cdn.jsdelivr.net/gh/g-ydg/images/blog/FqZ2t7CbF2JTYVct7X3Ly0Ju8ByJ.png"></p><ul><li><strong>代码重复</strong><ul><li>实现逻辑相同、执行流程相同</li></ul></li><li><strong>方法过长</strong><ul><li>方法中的语句不在同一个抽象层级</li><li>逻辑难以理解，需要大量的注释</li><li>面向过程编程而非面向对象</li></ul></li><li><strong>过大的类</strong><ul><li>类做了太多的事情</li><li>包含过多的实例变量和方法</li><li>类的命名不足以描述所做的事情</li></ul></li><li><strong>逻辑分散</strong><ul><li>发散式变化：某个类经常因为不同的原因在不同的方向上发生变化</li><li>散弹式修改：发生某种变化时，需要在多个类中做修改</li></ul></li><li><strong>严重的情结依恋</strong><ul><li>某个类的方法过多的使用其他类的成员</li></ul></li><li><strong>数据泥团/基本类型偏执</strong><ul><li>两个类、方法签名中包含相同的字段或参数</li><li>应该使用类但使用基本类型，比如表示数值与币种的 Money 类、起始值与结束值的 Range 类</li></ul></li><li><strong>不合理的继承体系</strong><ul><li>继承打破了封装性，子类依赖其父类中特定功能的实现细节</li><li>子类必须跟着其父类的更新而演变，除非父类是专门为了扩展而设计，并且有很好的文档说明</li></ul></li><li><strong>过多的条件判断</strong></li><li><strong>过长的参数列</strong></li><li><strong>临时变量过多</strong></li><li><strong>令人迷惑的暂时字段</strong><ul><li>某个实例变量仅为某种特定情况而设置</li><li>将实例变量与相应的方法提取到新的类中</li></ul></li><li><strong>纯数据类</strong><ul><li>仅包含字段和访问（读写）这些字段的方法</li><li>此类被称为数据容器，应保持最小可变性</li></ul></li><li><strong>不恰当的命名</strong><ul><li>命名无法准确描述做的事情</li><li>命名不符合约定俗称的惯例</li></ul></li><li><strong>过多的注释</strong></li></ul><h2 id="坏代码的问题"><a href="#坏代码的问题" class="headerlink" title="坏代码的问题"></a>坏代码的问题</h2><ul><li><strong>难以复用</strong><ul><li>系统关联性过多，导致很难分离可重用部分</li></ul></li><li><strong>难于变化</strong><ul><li>一处变化导致其他很多部分的修改，不利于系统稳定</li></ul></li><li><strong>难于理解</strong><ul><li>命名杂乱，结构混乱，难于阅读和理解</li></ul></li><li><strong>难以测试</strong><ul><li>分支、依赖较多，难以覆盖全面</li></ul></li></ul><h2 id="什么是好代码"><a href="#什么是好代码" class="headerlink" title="什么是好代码"></a>什么是好代码</h2><p><img src="https://cdn.jsdelivr.net/gh/g-ydg/images/blog/Fsx644dZvzId3kuGl5Ltm154V7FK.jpeg"></p><p>代码质量的评价有很强的主观性，描述代码质量的词汇也有很多，比如可读性、可维护性、灵活、优雅、简洁。这些词汇是从不同的维度去评价代码质量的。其中，可维护性、可读性、可扩展性又是提到最多的、最重要的三个评价标准。</p><p>要写出高质量代码，我们就需要掌握一些更加细化、更加能落地的编程方法论，这就包含面向对象设计思想、设计原则、设计模式、编码规范、重构技巧等。</p><h1 id="如何重构"><a href="#如何重构" class="headerlink" title="如何重构"></a>如何重构</h1><h2 id="SOLID-原则"><a href="#SOLID-原则" class="headerlink" title="SOLID 原则"></a>SOLID 原则</h2><p><img src="https://cdn.jsdelivr.net/gh/g-ydg/images/blog/FgDcHDOP9zogfhRMtAdbz2etc-n7.png"></p><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>一个类只负责完成一个职责或者功能，不要存在多于一种导致类变更的原因。</p><p>单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性。同时，类职责单一，类依赖的和被依赖的其他类也会变少，减少了代码的耦合性，以此来实现代码的高内聚、松耦合。但是，如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。</p><h3 id="开放-关闭原则"><a href="#开放-关闭原则" class="headerlink" title="开放-关闭原则"></a>开放-关闭原则</h3><p>添加一个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、方法、属性等），而非修改已有代码（修改模块、类、方法、属性等）的方式来完成。</p><p>开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。</p><p>很多设计原则、设计思想、设计模式，都是以提高代码的扩展性为最终目的的。特别是 23 种经典设计模式，大部分都是为了解决代码的扩展性问题而总结出来的，都是以开闭原则为指导原则的。最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态）。</p><h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><p>子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。</p><p>子类可以扩展父类的功能，但不能改变父类原有的功能</p><p>父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。</p><h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p>调用方不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。 接口隔离原则提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。</p><h3 id="依赖反转原则"><a href="#依赖反转原则" class="headerlink" title="依赖反转原则"></a>依赖反转原则</h3><p>高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。</p><h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><p>一个对象应该对其他对象保持最少的了解</p><h3 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h3><p>尽量使用合成/聚合的方式，而不是使用继承。</p><p>单一职责原则告诉我们实现类要职责单一；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合。而开闭原则是总纲，告诉我们要对扩展开放，对修改关闭。</p><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>设计模式：软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案。</p><p>设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。</p><ul><li><strong>创建型</strong>：主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码</li><li><strong>结构型</strong>：主要通过类或对象的不同组合，解耦不同功能的耦合</li><li><strong>行为型</strong>：主要解决的是类或对象之间的交互行为的耦合</li></ul><table><thead><tr><th>类型</th><th>模式</th><th>说明</th><th>适用场景</th></tr></thead><tbody><tr><td>创建型</td><td>单例</td><td>一个类只允许创建一个实例或对象，并为其提供一个全局的访问点</td><td>无状态/全局唯一/控制资源访问</td></tr><tr><td></td><td>工厂</td><td>创建一个或者多个相关的对象，而使用者不用关心具体的实现类</td><td>分离对象的创建和使用</td></tr><tr><td></td><td>建造者</td><td>用于创建一种类型的复杂对象，通过设置不同的可选参数进行“定制化”</td><td>对象的构造参数较多且多数可选</td></tr><tr><td></td><td>原型</td><td>通过复制已有对象来创建新的对象</td><td>对象的创建成本较大且同一类的不同对象之前差别不大</td></tr><tr><td>结构型</td><td>代理</td><td>不改变原始类和不使用继承的情况下，通过引入代理类来给原始类附加功能</td><td>增加代理访问，比如监控、缓存、限流、事务、RPC</td></tr><tr><td></td><td>装饰者</td><td>不改变原始类和不使用继承的情况下，通过组合的方式动态扩展原始类的功能</td><td>动态扩展类的功能</td></tr><tr><td></td><td>适配器</td><td>不改变原始类的情况下，通过组合的方式使其适配新的接口</td><td>复用现有类，但与期望接口不适配</td></tr><tr><td></td><td>桥接</td><td>当类存在多个独立变化的维度时，通过组合的方式使得其可以独立进行扩展</td><td>存在多个维度的继承体系时</td></tr><tr><td></td><td>门面</td><td>为子系统中一组接口定义一个更高层的接口，使得子系统更加容易使用</td><td>解决接口复用性（细粒度）与接口易用性（粗粒度）的矛盾</td></tr><tr><td></td><td>组合</td><td>将对象组合成树形结构以表示部分-整体的层次结构，统一单个对和组合对象的处理逻辑</td><td>满足部分与整体这种树形结构</td></tr><tr><td></td><td>享元</td><td>运用共享技术有效地支持大量细粒度的对象</td><td>当系统存在大量的对象，这些对象的很多字段取值范围固定</td></tr><tr><td>行为型</td><td>观察者</td><td>多个观察者监听同一主题对象，当主题对象状态发生变化时通知所有观察者，使它们能够自动更新自己</td><td>解耦事件创建者与接收者</td></tr><tr><td></td><td>模板</td><td>定义一个操作中算法的骨架，将某些步骤实现延迟到子类中</td><td>解决复用与扩展问题</td></tr><tr><td></td><td>策略</td><td>定义一组算法类，将每个算法分别封装起来，使得它们可以互相替换</td><td>消除各种 if-else 分支判断<br>解耦策略的定义、创建、使用</td></tr><tr><td></td><td>状态</td><td>允许一个对象在其内部状态改变的时候改变其行为</td><td>分离对象的状态与行为</td></tr><tr><td></td><td>职责链</td><td>将一组对象连成一条链，请求沿着该链传递，直到某个对象能够处理它为止</td><td>解耦请求的发送者与接收者</td></tr><tr><td></td><td>迭代器</td><td>提供一种方法顺序访问一个集合对象的各个元素，但不暴露该对象的内部表示</td><td>解耦集合对象的内部表示与遍历访问</td></tr><tr><td></td><td>访问者</td><td>封装一些作用于某种数据结构中各元素的操作，在不改变数据结构的前提下，定义作用于这些元素的新操作。</td><td>分离对象的数据结构与行为</td></tr><tr><td></td><td>备忘录</td><td>在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态</td><td>用于对象的备份与恢复</td></tr><tr><td></td><td>命令</td><td>将不同的请求封装成对应的命令对象，对命令的执行进行控制且对使用方透明</td><td>用于控制命令的执行，比如异步、延迟、排队、撤销、存储与撤销</td></tr><tr><td></td><td>解释器</td><td>为某个语言定义它的语法表示，并定义一个解释器来处理这个语法</td><td>用于编译器、规则引擎、正则表达式等特定场景</td></tr><tr><td></td><td>中介</td><td>定义一个单独的中介对象，来封装一组对象之间的交互，避免对象之间的直接交互</td><td>使各个对象不需要显式地相互引用，从而使其耦合松散</td></tr></tbody></table><h2 id="代码分层"><a href="#代码分层" class="headerlink" title="代码分层"></a>代码分层</h2><p><img src="https://cdn.jsdelivr.net/gh/g-ydg/images/blog/FhoEpGQYbmtY_ILLjLa87JOmBWTz.png"></p><p><strong>模块结构说明</strong></p><ul><li>server_main：配置层，负责整个项目的 module 管理，maven 配置管理、资源管理等；</li><li>server_application：应用接入层，承接外部流量入口，例如：RPC 接口实现、消息处理、定时任务等；不要在此包含业务逻辑；</li><li>server_biz：核心业务层，用例服务、领域实体、领域事件等</li><li>server_irepository：资源接口层，负责资源接口的暴露</li><li>server_repository：资源层，负责资源的 proxy 访问，统一外部资源访问，隔离变化。注意：这里强调的是弱业务性，强数据性；</li><li>server_common：公共层，vo、工具等</li></ul><p>代码开发要遵守各层的规范，并注意层级之间的依赖关系。</p><h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><p>一个好的命名应该要满足以下两个约束：</p><ul><li>准确描述所做得事情</li><li>格式符合通用的惯例</li></ul><p>如果你觉得一个类或方法难以命名的时候，可能是其承载的功能太多了，需要进一步拆分。</p><h3 id="约定俗称的惯例"><a href="#约定俗称的惯例" class="headerlink" title="约定俗称的惯例"></a>约定俗称的惯例</h3><table><thead><tr><th>场景</th><th>强约束</th><th>示例</th></tr></thead><tbody><tr><td>项目名</td><td>全部小写，多个单词用中划线分隔‘-’</td><td>spring-cloud</td></tr><tr><td>包名</td><td>全部小写</td><td>com.alibaba.fastjson</td></tr><tr><td>类名/接口名</td><td>单词首字母大写</td><td>ParserConfig,DefaultFieldDeserializer</td></tr><tr><td>变量名</td><td>首字母小写，多个单词组成时，除首个单词，其他单词首字母都要大写</td><td>password, userName</td></tr><tr><td>常量名</td><td>全部大写，多个单词，用’_‘分隔</td><td>CACHE_EXPIRED_TIME</td></tr><tr><td>方法</td><td>同变量</td><td>read(), readObject(), getById()</td></tr></tbody></table><h3 id="类命名"><a href="#类命名" class="headerlink" title="类命名"></a>类命名</h3><p>类名使用大驼峰命名形式，类命通常使用名词或名词短语。接口名除了用名词和名词短语以外，还可以使用形容词或形容词短语，如 Cloneable，Callable 等，表示实现该接口的类有某种功能或能力。</p><table><thead><tr><th>场景</th><th>约束</th><th>示例</th></tr></thead><tbody><tr><td>抽象类</td><td>Abstract 或者 Base 开头</td><td>BaseUserService</td></tr><tr><td>枚举类</td><td>Enum 作为后缀</td><td>GenderEnum</td></tr><tr><td>工具类</td><td>Utils 作为后缀</td><td>StringUtils</td></tr><tr><td>异常类</td><td>Exception 结尾</td><td>RuntimeException</td></tr><tr><td>接口实现类</td><td>接口名+ Impl</td><td>UserServiceImpl</td></tr><tr><td>设计模式相关类</td><td>Builder，Factory 等</td><td>当使用到设计模式时，需要使用对应的设计模式作为后缀，如 ThreadFactory</td></tr><tr><td>处理特定功能的类</td><td>Handler，Predicate, Validator</td><td>表示处理器，校验器，断言，这些类工厂还有配套的方法名如 handle，predicate，validate</td></tr><tr><td>特定层级的类</td><td>Controller，Service，ServiceImpl，Dao 后缀</td><td>UserController, UserServiceImpl，UserDao</td></tr><tr><td>特定层级的值对象</td><td>Ao, Param, Vo，Config, Message</td><td>Param 调用入参；Ao 为 thrift 返回结果；Vo 通用值对象；<br>Config 配置类；Message 为 MQ 消息</td></tr><tr><td>测试类</td><td>Test 结尾</td><td>UserServiceTest， 表示用来测试 UserService 类的</td></tr></tbody></table><h3 id="方法命名"><a href="#方法命名" class="headerlink" title="方法命名"></a>方法命名</h3><p>方法命名采用小驼峰的形式，首字小写，往后的每个单词首字母都要大写。和类名不同的是，方法命名一般为动词或动词短语，与参数或参数名共同组成动宾短语，即动词 + 名词。一个好的函数名一般能通过名字直接获知该函数实现什么样的功能。</p><table><thead><tr><th>场景</th><th>约束</th><th>示例</th></tr></thead><tbody><tr><td>返回真伪值</td><td>is/can/has/needs/should</td><td>isValid/canRemove</td></tr><tr><td>用于检查</td><td>ensure/validate</td><td>ensureCapacity/validateInputs</td></tr><tr><td>按需执行</td><td>IfNeeded/try/OrDefault/OrElse</td><td>drawIfNeeded/tryCreate/getOrDefault</td></tr><tr><td>数据相关</td><td>get/search/save/update/batchSave/<br>batchUpdate/saveOrUpdateselect<br>/insert/update/delete</td><td>getUserById/searchUsersByCreateTime</td></tr><tr><td>生命周期</td><td>initialize/pause/stop/destroy</td><td>initialize/pause/onPause/stop/onStop</td></tr><tr><td>常用动词对</td><td>split/join、inject/extract、bind/seperate、<br>increase/decrease、lanch/run、observe/listen、build/publish、<br>encode/decode、submit/commit、push/pull、enter/exit、<br>expand/collapse、encode/decode</td><td></td></tr></tbody></table><h2 id="重构技巧"><a href="#重构技巧" class="headerlink" title="重构技巧"></a>重构技巧</h2><h3 id="提炼方法"><a href="#提炼方法" class="headerlink" title="提炼方法"></a>提炼方法</h3><p>多个方法代码重复、方法中代码过长或者方法中的语句不在一个抽象层级。方法是代码复用的最小粒度，方法过长不利于复用，可读性低，提炼方法往往是重构工作的第一步。</p><p><strong>意图导向编程</strong>：把处理某件事的流程和具体做事的实现方式分开。</p><ul><li>把一个问题分解为一系列功能性步骤，并假定这些功能步骤已经实现</li><li>我们只需把把各个函数组织在一起即可解决这一问题</li><li>在组织好整个功能后，我们在分别实现各个方法函数</li></ul><p>/**<br>  _ 1、交易信息开始于一串标准 ASCII 字符串。<br>  _ 2、这个信息字符串必须转换成一个字符串的数组，数组存放的此次交易的领域语言中所包含的词汇元素（token)。<br>  _ 3、每一个词汇必须标准化。<br>  _ 4、包含超过 150 个词汇元素的交易，应该采用不同于小型交易的方式（不同的算法）来提交，以提高效率。<br>  _ 5、如果提交成功，API 返回”true”；失败，则返回”false”。<br>  _/<br>public class Transaction {   <br>  public Boolean commit(String command) {       <br>    Boolean result = true;       <br>    String[] tokens = tokenize(command);       <br>    normalizeTokens(tokens);       <br>    if (isALargeTransaction(tokens)) {           <br>      result = processLargeTransaction(tokens);       <br>    } else {           <br>      result = processSmallTransaction(tokens);       <br>    }       <br>    return result;   <br>  }<br>}<br>复制代码</p><h3 id="以函数对象取代函数"><a href="#以函数对象取代函数" class="headerlink" title="以函数对象取代函数"></a>以函数对象取代函数</h3><p>将函数放进一个单独对象中，如此一来局部变量就变成了对象内的字段。然后你可以在同一个对象中将这个大型函数分解为多个小型函数。</p><h3 id="引入参数对象"><a href="#引入参数对象" class="headerlink" title="引入参数对象"></a>引入参数对象</h3><p>方法参数比较多时，将参数封装为参数对象</p><h3 id="移除对参数的赋值"><a href="#移除对参数的赋值" class="headerlink" title="移除对参数的赋值"></a>移除对参数的赋值</h3><p>public int discount(int inputVal, int quantity, int yearToDate) {<br>  if (inputVal &gt; 50) inputVal -= 2;<br>  if (quantity &gt; 100) inputVal -= 1;<br>  if (yearToDate &gt; 10000) inputVal -= 4;<br>  return inputVal;<br>}</p><p>public int discount(int inputVal, int quantity, int yearToDate) {<br>  int result = inputVal;<br>  if (inputVal &gt; 50) result -= 2;<br>  if (quantity &gt; 100) result -= 1;<br>  if (yearToDate &gt; 10000) result -= 4;<br>  return result;<br>}<br>复制代码</p><h3 id="将查询与修改分离"><a href="#将查询与修改分离" class="headerlink" title="将查询与修改分离"></a>将查询与修改分离</h3><p>任何有返回值的方法，都不应该有副作用</p><ul><li>不要在 convert 中调用写操作，避免副作用</li><li>常见的例外：将查询结果缓存到本地</li></ul><h3 id="移除不必要临时变量"><a href="#移除不必要临时变量" class="headerlink" title="移除不必要临时变量"></a>移除不必要临时变量</h3><p>临时变量仅使用一次或者取值逻辑成本很低的情况下</p><h3 id="引入解释性变量"><a href="#引入解释性变量" class="headerlink" title="引入解释性变量"></a>引入解释性变量</h3><p>将复杂表达式（或其中一部分）的结果放进一个临时变量，以此变量名称来解释表达式用途</p><p>if ((platform.toUpperCase().indexOf(“MAC”) &gt; -1)<br>&amp;&amp; (browser.toUpperCase().indexOf(“IE”) &gt; -1) &amp;&amp; wasInitialized() &amp;&amp; resize &gt; 0) {  <br>  // do something<br>}</p><p>final boolean isMacOs = platform.toUpperCase().indexOf(“MAC”) &gt; -1;<br>final boolean isIEBrowser = browser.toUpperCase().indexOf(“IE”) &gt; -1;<br>final boolean wasResized = resize &gt; 0;<br>if (isMacOs &amp;&amp; isIEBrowser &amp;&amp; wasInitialized() &amp;&amp; wasResized) {  <br>  // do something<br>}<br>复制代码</p><h3 id="使用卫语句替代嵌套条件判断"><a href="#使用卫语句替代嵌套条件判断" class="headerlink" title="使用卫语句替代嵌套条件判断"></a>使用卫语句替代嵌套条件判断</h3><p>把复杂的条件表达式拆分成多个条件表达式，减少嵌套。嵌套了好几层的 if - then-else 语句，转换为多个 if 语句</p><p>//未使用卫语句<br>public void getHello(int type) {<br>    if (type == 1) {<br>        return;<br>    } else {<br>        if (type == 2) {<br>            return;<br>        } else {<br>            if (type == 3) {<br>                return;<br>            } else {<br>                setHello();<br>            }<br>        }<br>    }<br>}</p><p>//使用卫语句<br>public void getHello(int type) {<br>    if (type == 1) {<br>        return;<br>    }<br>    if (type == 2) {<br>        return;<br>    }<br>    if (type == 3) {<br>        return;<br>    }<br>    setHello();<br>}<br>复制代码</p><h3 id="使用多态替代条件判断断"><a href="#使用多态替代条件判断断" class="headerlink" title="使用多态替代条件判断断"></a>使用多态替代条件判断断</h3><p>当存在这样一类条件表达式，它根据对象类型的不同选择不同的行为。可以将这种表达式的每个分支放进一个子类内的复写函数中，然后将原始函数声明为抽象函数。</p><p>public int calculate(int a, int b, String operator) {<br>    int result = Integer.MIN_VALUE;</p><p>if (“add”.equals(operator)) {<br>        result = a + b;<br>    } else if (“multiply”.equals(operator)) {<br>        result = a * b;<br>    } else if (“divide”.equals(operator)) {<br>        result = a / b;<br>    } else if (“subtract”.equals(operator)) {<br>        result = a - b;<br>    }<br>    return result;<br>}<br>复制代码</p><p>当出现大量类型检查和判断时，if else（或 switch）语句的体积会比较臃肿，这无疑降低了代码的可读性。  另外，if else（或 switch）本身就是一个“变化点”，当需要扩展新的类型时，我们不得不追加 if else（或 switch）语句块，以及相应的逻辑，这无疑降低了程序的可扩展性，也违反了面向对象的开闭原则。</p><p>基于这种场景，我们可以考虑使用“多态”来代替冗长的条件判断，将 if else（或 switch）中的“变化点”封装到子类中。这样，就不需要使用 if else（或 switch）语句了，取而代之的是子类多态的实例，从而使得提高代码的可读性和可扩展性。很多设计模式使用都是这种套路，比如策略模式、状态模式。</p><p>public interface Operation {<br>  int apply(int a, int b);<br>}</p><p>public class Addition implements Operation {<br>  @Override<br>  public int apply(int a, int b) {<br>    return a + b;<br>  }<br>}</p><p>public class OperatorFactory {<br>    private final static Map&lt;String, Operation&gt; operationMap = new HashMap&lt;&gt;();<br>    static {<br>        operationMap.put(“add”, new Addition());<br>        operationMap.put(“divide”, new Division());<br>        // more operators<br>    }</p><p>public static Operation getOperation(String operator) {<br>        return operationMap.get(operator);<br>    }<br>}</p><p>public int calculate(int a, int b, String operator) {<br>    if (OperatorFactory .getOperation == null) {<br>      throw new IllegalArgumentException(“Invalid Operator”);<br>    }<br>    return OperatorFactory .getOperation(operator).apply(a, b);<br>}<br>复制代码</p><h3 id="使用异常替代返回错误码"><a href="#使用异常替代返回错误码" class="headerlink" title="使用异常替代返回错误码"></a>使用异常替代返回错误码</h3><p>非正常业务状态的处理，使用抛出异常的方式代替返回错误码</p><ul><li>不要使用异常处理用于正常的业务流程控制<ul><li>异常处理的性能成本非常高</li></ul></li><li>尽量使用标准异常</li><li>避免在 finally 语句块中抛出异常<ul><li>如果同时抛出两个异常，则第一个异常的调用栈会丢失</li><li>finally 块中应只做关闭资源这类的事情</li></ul></li></ul><p>//使用错误码<br>public boolean withdraw(int amount) {<br>    if (balance &lt; amount) {<br>        return false;<br>    } else {<br>        balance -= amount;<br>        return true;<br>    }<br>}</p><p>//使用异常<br>public void withdraw(int amount) {<br>    if (amount &gt; balance) {<br>        throw new IllegalArgumentException(“amount too large”);   <br>    }<br>    balance -= amount;<br>}<br>复制代码</p><h3 id="引入断言"><a href="#引入断言" class="headerlink" title="引入断言"></a>引入断言</h3><p>某一段代码需要对程序状态做出某种假设，以断言明确表现这种假设。</p><ul><li>不要滥用断言，不要使用它来检查“应该为真”的条件，只使用它来检查“一定必须为真”的条件</li><li>如果断言所指示的约束条件不能满足，代码是否仍能正常运行？如果可以就去掉断言</li></ul><h3 id="引入-Null-对象或特殊对象"><a href="#引入-Null-对象或特殊对象" class="headerlink" title="引入 Null 对象或特殊对象"></a>引入 Null 对象或特殊对象</h3><p>当使用一个方法返回的对象时，而这个对象可能为空，这个时候需要对这个对象进行操作前，需要进行判空，否则就会报空指针。当这种判断频繁的出现在各处代码之中，就会影响代码的美观程度和可读性，甚至增加 Bug 的几率。</p><p>空引用的问题在 Java 中无法避免，但可以通过代码编程技巧（引入空对象）来改善这一问题。</p><p>//空对象的例子<br>public class OperatorFactory {<br>  static Map&lt;String, Operation&gt; operationMap = new HashMap&lt;&gt;();<br>  static {<br>    operationMap.put(“add”, new Addition());<br>    operationMap.put(“divide”, new Division());<br>    // more operators<br>  }<br>  public static Optional<operation>getOperation(String operator) {<br>    return Optional.ofNullable(operationMap.get(operator));<br>  }<br>}<br>public int calculate(int a, int b, String operator) {<br>  Operation targetOperation = OperatorFactory.getOperation(operator)<br>    .orElseThrow(() -&gt; new IllegalArgumentException(“Invalid Operator”));<br>  return targetOperation.apply(a, b);<br>}</operation></p><p>//特殊对象的例子<br>public class InvalidOp implements Operation {<br>  @Override<br>  public int apply(int a, int b)  {<br>    throw new IllegalArgumentException(“Invalid Operator”);<br>  }<br>}<br>复制代码</p><h3 id="提炼类"><a href="#提炼类" class="headerlink" title="提炼类"></a>提炼类</h3><p>根据单一职责原则，一个类应该有明确的责任边界。但在实际工作中，类会不断的扩展。当给某个类添加一项新责任时，你会觉得不值得分离出一个单独的类。于是，随着责任不断增加，这个类包含了大量的数据和函数，逻辑复杂不易理解。</p><p>此时你需要考虑将哪些部分分离到一个单独的类中，可以依据高内聚低耦合的原则。如果某些数据和方法总是一起出现，或者某些数据经常同时变化，这就表明它们应该放到一个类中。另一种信号是类的子类化方式：如果你发现子类化只影响类的部分特性，或者类的特性需要以不同方式来子类化，这就意味着你需要分解原来的类。</p><p>//原始类<br>public class Person {<br>    private String name;<br>    private String officeAreaCode;<br>    private String officeNumber;</p><p>public String getName() {<br>        return name;<br>    }</p><p>public String getTelephoneNumber() {<br>        return (“(“ + officeAreaCode + “)” + officeNumber);<br>    }</p><p>public String getOfficeAreaCode() {<br>        return officeAreaCode;<br>    }</p><p>public void setOfficeAreaCode(String arg) {<br>        officeAreaCode = arg;<br>    }</p><p>public String getOfficeNumber() {<br>        return officeNumber;<br>    }</p><p>public void setOfficeNumber(String arg) {<br>        officeNumber = arg;<br>    }<br>}</p><p>//新提炼的类（以对象替换数据值）<br>public class TelephoneNumber {<br>    private String areaCode;<br>    private String number;</p><p>public String getTelephnoeNumber() {<br>        return (“(“ + getAreaCode() + “)” + number);<br>    }</p><p>String getAreaCode() {<br>        return areaCode;<br>    }</p><p>void setAreaCode(String arg) {<br>        areaCode = arg;<br>    }</p><p>String getNumber() {<br>        return number;<br>    }</p><p>void setNumber(String arg) {<br>        number = arg;<br>    }<br>}<br>复制代码</p><h3 id="组合优先于继承"><a href="#组合优先于继承" class="headerlink" title="组合优先于继承"></a>组合优先于继承</h3><p>继承使实现代码重用的有力手段，但这并非总是完成这项工作的最佳工具，使用不当会导致软件变得很脆弱。与方法调用不同的是，继承打破了封装性。子类依赖于其父类中特定功能的实现细节，如果父类的实现随着发行版本的不同而变化，子类可能会遭到破坏，即使他的代码完全没有改变。</p><p>举例说明，假设有一个程序使用 HashSet，为了调优该程序的性能，需要统计 HashSet 自从它创建以来添加了多少个元素。为了提供该功能，我们编写一个 HashSet 的变体。</p><p>// Inappropriate use of inheritance!<br>public class InstrumentedHashSet<e>extends HashSet<e>{<br>    // The number of attempted element insertions<br>    private int addCount = 0;</e></e></p><p>public InstrumentedHashSet() { }</p><p>public InstrumentedHashSet(int initCap, float loadFactor) {<br>        super(initCap, loadFactor);<br>    }</p><p>@Override<br>    public boolean add(E e) {<br>        addCount++;<br>        return super.add(e);<br>    }</p><p>@Override<br>    public boolean addAll(Collection&lt;? extends E&gt; c) {<br>        addCount += c.size();<br>        return super.addAll(c);<br>    }</p><p>public int getAddCount() {<br>        return addCount;<br>    }<br>}<br>复制代码</p><p>通过在新的类中增加一个私有域，它引用现有类的一个实例，这种设计被称为组合，因为现有的类变成了新类的一个组件。这样得到的类将会非常稳固，它不依赖现有类的实现细节。即使现有的类添加了新的方法，也不会影响新的类。许多设计模式使用就是这种套路，比如代理模式、装饰者模式</p><p>// Reusable forwarding class<br>public class ForwardingSet<e>implements Set<e>{<br>    private final Set<e>s;<br>    public ForwardingSet(Set<e>s) { this.s = s; }</e></e></e></e></p><p>    @Override<br>    public int size() { return s.size(); }<br>    @Override<br>    public boolean isEmpty() { return s.isEmpty(); }<br>    @Override<br>    public boolean contains(Object o) { return s.contains(o); }<br>    @Override<br>    public Iterator<e>iterator() { return s.iterator(); }<br>    @Override<br>    public Object[] toArray() { return s.toArray(); }<br>    @Override<br>    public<t>T[] toArray(T[] a) { return s.toArray(a); }<br>    @Override<br>    public boolean add(E e) { return s.add(e); }<br>    @Override<br>    public boolean remove(Object o) { return s.remove(o); }<br>    @Override<br>    public boolean containsAll(Collection<?> c) { return s.containsAll(c); }  
    @Override  
    public boolean addAll(Collection<? extends E> c) { return s.addAll(c); }  
    @Override  
    public boolean retainAll(Collection<?> c) { return s.retainAll(c); }<br>    @Override<br>    public boolean removeAll(Collection&lt;?&gt; c) { return s.removeAll(c); }<br>    @Override<br>    public void clear() { s.clear(); }<br>}</t></e></p><p>// Wrappter class - uses composition in place of inheritance<br>public class InstrumentedHashSet<e>extends ForwardingSet<e>{<br>    private int addCount = 0;</e></e></p><p>public InstrumentedHashSet1(Set<e>s) {<br>        super(s);<br>    }</e></p><p>@Override<br>    public boolean add(E e) {<br>        addCount++;<br>        return super.add(e);<br>    }</p><p>@Override<br>    public boolean addAll(Collection&lt;? extends E&gt; c) {<br>        addCount += c.size();<br>        return super.addAll(c);<br>    }</p><p>public int getAddCount() {<br>        return addCount;<br>    }<br>}<br>复制代码</p><p><strong>继承与组合如何取舍</strong></p><ul><li>只有当子类真正是父类的子类型时，才适合继承。对于两个类 A 和 B，只有两者之间确实存在“is-a”关系的时候，类 B 才应该继承 A；</li><li>在包的内部使用继承是非常安全的，子类和父类的实现都处在同一个程序员的控制之下；</li><li>对于专门为了继承而设计并且具有很好的文档说明的类来说，使用继承也是非常安全的；</li><li>其他情况就应该优先考虑组合的方式来实现</li></ul><h3 id="接口优于抽象类"><a href="#接口优于抽象类" class="headerlink" title="接口优于抽象类"></a>接口优于抽象类</h3><p>Java 提供了两种机制，可以用来定义允许多个实现的类型：接口和抽象类。自从 Java8 为接口增加缺省方法（default method），这两种机制都允许为实例方法提供实现。主要区别在于，为了实现由抽象类定义的类型，类必须称为抽象类的一个子类。因为 Java 只允许单继承，所以用抽象类作为类型定义受到了限制。</p><p>接口相比于抽象类的优势：</p><ul><li>现有的类可以很容易被更新，以实现新的接口。</li><li>接口是定义混合类型（比如 Comparable）的理想选择。</li><li>接口允许构造非层次结构的类型框架。</li></ul><p>接口虽然提供了缺省方法，但接口仍有有以下局限性：</p><ul><li>接口的变量修饰符只能是 public static final 的</li><li>接口的方法修饰符只能是 public 的</li><li>接口不存在构造函数，也不存在 this</li><li>可以给现有接口增加缺省方法，但不能确保这些方法在之前存在的实现中都能良好运行。<ul><li>因为这些默认方法是被注入到现有实现中的，它们的实现者并不知道，也没有许可</li></ul></li></ul><p>接口缺省方法的设计目的和优势在于：</p><ul><li>为了接口的演化<ul><li>Java 8 之前我们知道，一个接口的所有方法其子类必须实现（当然，这个子类不是一个抽象类），但是 java 8 之后接口的默认方法可以选择不实现，如上的操作是可以通过编译期编译的。这样就避免了由 Java 7 升级到 Java 8 时项目编译报错了。Java8 在核心集合接口中增加了许多新的缺省方法，主要是为了便于使用 lambda。</li></ul></li><li>可以减少第三方工具类的创建<ul><li>例如在 List 等集合接口中都有一些默认方法，List 接口中默认提供  replaceAll(UnaryOperator)、sort(Comparator)、、spliterator()等默认方法，这些方法在接口内部创建，避免了为了这些方法而专门去创建相应的工具类。</li></ul></li><li>可以避免创建基类<ul><li>在 Java 8 之前我们可能需要创建一个基类来实现代码复用，而默认方法的出现，可以不必要去创建基类。</li></ul></li></ul><p><strong>由于接口的局限性和设计目的的不同，接口并不能完全替换抽象类。但是通过对接口提供一个抽象的骨架实现类，可以把接口和抽象类的优点结合起来。</strong> 接口负责定义类型，或许还提供一些缺省方法，而骨架实现类则负责实现除基本类型接口方法之外，剩下的非基本类型接口方法。扩展骨架实现占了实现接口之外的大部分工作。这就是模板方法（Template Method）设计模式。</p><p><img src="https://cdn.jsdelivr.net/gh/g-ydg/images/blog/FoQjsDq7p3AB0a7bLgGkEFYB_IQv.png"></p><p>接口 Protocol：定义了 RPC 协议层两个主要的方法，export 暴露服务和 refer 引用服务</p><p>抽象类 AbstractProtocol：封装了暴露服务之后的 Exporter 和引用服务之后的 Invoker 实例，并实现了服务销毁的逻辑</p><p>具体实现类 XxxProtocol：实现 export 暴露服务和 refer 引用服务具体逻辑</p><h3 id="优先考虑泛型"><a href="#优先考虑泛型" class="headerlink" title="优先考虑泛型"></a>优先考虑泛型</h3><p>声明中具有一个或者多个类型参数（type parameter）的类或者接口，就是泛型（generic）类或者接口。泛型类和接口统称为泛型（generic type）。泛型从 Java 5 引入，提供了编译时类型安全检测机制。泛型的本质是参数化类型，通过一个参数来表示所操作的数据类型，并且可以限制这个参数的类型范围。泛型的好处就是编译期类型检测，避免类型转换。</p><p>// 比较三个值并返回最大值<br>public static &lt;T extends Comparable<t>&gt; T maximum(T x, T y, T z) {  <br>  T max = x;<br>  // 假设 x 是初始最大值   <br>  if ( y.compareTo( max ) &gt; 0 ) {     <br>    max = y; //y 更大  <br>  }   if ( z.compareTo( max ) &gt; 0 ) {    <br>    max = z; // 现在 z 更大              <br>  }   return max; // 返回最大对象<br>}</t></p><p>public static void main( String args[] ) {  <br>  System.out.printf( “%d, %d 和 %d 中最大的数为 %d\n\n”,  3, 4, 5, maximum( 3, 4, 5 ));  <br>  System.out.printf( “%.1f, %.1f 和 %.1f 中最大的数为 %.1f\n\n”,  6.6, 8.8, 7.7,  maximum( 6.6, 8.8, 7.7 ));  <br>  System.out.printf( “%s, %s 和 %s 中最大的数为 %s\n”,”pear”, “apple”, “orange”, maximum( “pear”, “apple”, “orange” ) );<br>}<br>复制代码</p><h4 id="不要使用原生态类型"><a href="#不要使用原生态类型" class="headerlink" title="不要使用原生态类型"></a>不要使用原生态类型</h4><p>由于为了保持 Java 代码的兼容性，支持和原生态类型转换，并使用擦除机制实现的泛型。但是使用原生态类型就会失去泛型的优势，会受到编译器警告。</p><h4 id="要尽可能地消除每一个非受检警告"><a href="#要尽可能地消除每一个非受检警告" class="headerlink" title="要尽可能地消除每一个非受检警告"></a>要尽可能地消除每一个非受检警告</h4><p>每一条警告都表示可能在运行时抛出 ClassCastException 异常。要尽最大的努力去消除这些警告。如果无法消除但是可以证明引起警告的代码是安全的，就可以在尽可能小的范围中，使用＠SuppressWarnings(“unchecked”)注解来禁止警告，但是要把禁止的原因记录下来。</p><h4 id="利用有限制通配符来提升-API-的灵活性"><a href="#利用有限制通配符来提升-API-的灵活性" class="headerlink" title="利用有限制通配符来提升 API 的灵活性"></a>利用有限制通配符来提升 API 的灵活性</h4><p>参数化类型不支持协变的，即对于任何两个不同的类型 Type1 和 Type2 而言，List 既不是 List 的子类型，也不是它的超类。为了解决这个问题，提高灵活性，Java 提供了一种特殊的参数化类型，称作有限制的通配符类型，即 List&lt;? extends E&gt;和 List&lt;? super E&gt;。使用原则是 producer-extends，consumer-super（PECS）。如果即是生产者，又是消费者，就没有必要使用通配符了。</p><p>还有一种特殊的无限制通配符 List&lt;?&gt;，表示某种类型但不确定。常用作泛型的引用，不可向其添加除 Null 以外的任何对象。</p><p>//List&lt;? extends E&gt;<br>// Number 可以认为 是 Number 的 “子类”<br>List&lt;? extends Number&gt; numberArray = new ArrayList<number>();<br>// Integer 是 Number 的子类<br>List&lt;? extends Number&gt; numberArray = new ArrayList<integer>();<br>// Double 是 Number 的子类<br>List&lt;? extends Number&gt; numberArray = new ArrayList<double>();</double></integer></number></p><p>//List&lt;? super E&gt;<br>// Integer 可以认为是 Integer 的 “父类”<br>List&lt;? super Integer&gt; array = new ArrayList<integer>();、<br>// Number 是 Integer 的 父类<br>List&lt;? super Integer&gt; array = new ArrayList<number>();<br>// Object 是 Integer 的 父类<br>List&lt;? super Integer&gt; array = new ArrayList<object>();</object></number></integer></p><p>public static<t>void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) {   <br>  int srcSize = src.size();   <br>  if (srcSize &gt; dest.size())       <br>  throw new IndexOutOfBoundsException(“Source does not fit in dest”);   <br>  if (srcSize &lt; COPY_THRESHOLD || (src instanceof RandomAccess &amp;&amp; dest instanceof RandomAccess)) {       <br>    for (int i=0; i&lt;srcSize; i++)           <br>    dest.set(i, src.get(i));   <br>  } else {       <br>    ListIterator&lt;? super T&gt; di=dest.listIterator();       <br>    ListIterator&lt;? extends T&gt; si=src.listIterator();       <br>    for (int i=0; i&lt;srcSize; i++) {           <br>      di.next();           <br>      di.set(si.next());       <br>    }   <br>  }<br>}<br>复制代码</t></p><h3 id="静态成员类优于非静态成员类"><a href="#静态成员类优于非静态成员类" class="headerlink" title="静态成员类优于非静态成员类"></a>静态成员类优于非静态成员类</h3><p>嵌套类（nested class）是指定义在另一个类的内部的类。<strong>嵌套类存在的目的只是为了它的外部类提供服务，如果其他的环境也会用到的话，应该成为一个顶层类（top-level class）。</strong> 嵌套类有四种：静态成员类（static member class）、非静态成员类（nonstatic member class）、匿名类（anonymous class）和 局部类（local class）。除了第一种之外，其他三种都称为内部类（inner class）。</p><h4 id="匿名类（anonymous-class）"><a href="#匿名类（anonymous-class）" class="headerlink" title="匿名类（anonymous class）"></a>匿名类（anonymous class）</h4><p>没有名字，声明的同时进行实例化，只能使用一次。当出现在非静态的环境中，会持有外部类实例的引用。通常用于创建函数对象和过程对象，不过现在会优先考虑 lambda。</p><h4 id="局部类（local-class）"><a href="#局部类（local-class）" class="headerlink" title="局部类（local class）"></a>局部类（local class）</h4><p>任何可以声明局部变量的地方都可以声明局部类，同时遵循同样的作用域规则。跟匿名类不同的是，有名字可以重复使用。不过实际很少使用局部类。</p><h4 id="静态成员类（static-member-class）"><a href="#静态成员类（static-member-class）" class="headerlink" title="静态成员类（static member class）"></a>静态成员类（static member class）</h4><p>最简单的一种嵌套类，声明在另一个类的内部，是这个类的静态成员，遵循同样的可访问性规则。常见的用法是作为公有的辅助类，只有与它的外部类一起使用才有意义。</p><h4 id="非静态成员类（nonstatic-member-class）"><a href="#非静态成员类（nonstatic-member-class）" class="headerlink" title="非静态成员类（nonstatic member class）"></a>非静态成员类（nonstatic member class）</h4><p>尽管语法上，跟静态成员类的唯一区别就是类的声明不包含 static，但两者有很大的不同。非静态成员类的每个实例都隐含地与外部类的实例相关联，可以访问外部类的成员属性和方法。另外必须先创建外部类的实例之后才能创建非静态成员类的实例。</p><p>总而言之，这四种嵌套类都有自己的用途。假设这个嵌套类属于一个方法的内部，如果只需要在一个地方创建实例，并且已经有了一个预置的类型可以说明这个类的特征，就要把它做成匿名类。如果一个嵌套类需要在单个方法之外仍然可见，或者它太长了，不适合放在方法内部，就应该使用成员类。如果成员类的每个实例都需要一个指向其外围实例的引用，就要把成员类做成非静态的，否则就做成静态的。</p><h3 id="优先使用模板-工具类"><a href="#优先使用模板-工具类" class="headerlink" title="优先使用模板/工具类"></a>优先使用模板/工具类</h3><p>通过对常见场景的代码逻辑进行抽象封装，形成相应的模板工具类，可以大大减少重复代码，专注于业务逻辑，提高代码质量。</p><h3 id="分离对象的创建与使用"><a href="#分离对象的创建与使用" class="headerlink" title="分离对象的创建与使用"></a>分离对象的创建与使用</h3><p>面向对象编程相对于面向过程，多了实例化这一步，而对象的创建必须要指定具体类型。我们常见的做法是“哪里用到，就在哪里创建”，使用实例和创建实例的是同一段代码。这似乎使代码更具有可读性，但是某些情况下造成了不必要的耦合。</p><p>public class BusinessObject {<br>public void actionMethond {<br>    //Other things<br>    Service myServiceObj = new Service();<br>      myServiceObj.doService();<br>      //Other things<br>    }<br>}</p><p>public class BusinessObject {<br>public void actionMethond {<br>    //Other things<br>    Service myServiceObj = new ServiceImpl();<br>      myServiceObj.doService();<br>      //Other things<br>    }<br>}</p><p>public class BusinessObject {<br>  private Service myServiceObj;<br>  public BusinessObject(Service aService) {<br>      myServiceObj = aService;<br>    }<br>public void actionMethond {<br>    //Other things<br>      myServiceObj.doService();<br>      //Other things<br>    }<br>}</p><p>public class BusinessObject {<br>  private Service myServiceObj;<br>  public BusinessObject() {<br>      myServiceObj = ServiceFactory;<br>    }<br>public void actionMethond {<br>    //Other things<br>      myServiceObj.doService();<br>      //Other things<br>    }<br>}<br>复制代码</p><p>对象的创建者耦合的是对象的具体类型，而对象的使用者耦合的是对象的接口。也就是说，创建者关心的是这个对象是什么，而使用者关心的是它能干什么。这两者应该视为独立的考量，它们往往会因为不同的原因而改变。</p><p>当对象的类型涉及多态、对象创建复杂（依赖较多）可以考虑将对象的创建过程分离出来，使得使用者不用关注对象的创建细节。设计模式中创建型模式的出发点就是如此，实际项目中可以使用工厂模式、构建器、依赖注入的方式。</p><h3 id="可访问性最小化"><a href="#可访问性最小化" class="headerlink" title="可访问性最小化"></a>可访问性最小化</h3><p>区分一个组件设计得好不好，一个很重要的因素在于，它对于外部组件而言，是否隐藏了其内部数据和实现细节。Java 提供了访问控制机制来决定类、接口和成员的可访问性。实体的可访问性由该实体声明所在的位置，以及该实体声明中所出现的访问修饰符（private、protected、public）共同决定的。</p><p>对于顶层的（非嵌套的）类和接口，只有两种的访问级别：包级私有的（没有 public 修饰）和公有的（public 修饰）。</p><p>对于成员（实例/域、方法、嵌套类和嵌套接口）由四种的访问级别，可访问性如下递增：</p><ul><li>私有的（private 修饰）–只有在声明该成员的顶层类内部才可以访问这个成员；</li><li>包级私有的（默认）–声明该成员的包内部的任何类都可以访问这个成员；</li><li>受保护的（protected 修饰）–声明该成员的类的子类可以访问这个成员，并且声明该成员的包内部的任何类也可以访问这个成员；</li><li>公有的（public 修饰）–在任何地方都可以访问该成员；</li></ul><p>正确地使用这些修饰符对于实现信息隐藏是非常关键的，原则就是：尽可能地使每个类和成员不被外界访问（私有或包级私有）。这样好处就是在以后的发行版本中，可以对它进行修改、替换或者删除，而无须担心会影响现有的客户端程序。</p><ul><li>如果类或接口能够做成包级私有的，它就应该被做成包级私有的；</li><li>如果一个包级私有的顶层类或接口只是在某一个类的内部被用到，就应该考虑使它成为那个类的私有嵌套类；</li><li>公有类不应直接暴露实例域，应该提供相应的方法以保留将来改变该类的内部表示法的灵活性；</li><li>当确定了类的公有 API 之后，应该把其他的成员都变成私有的；</li><li>如果同一个包下的类之间存在比较多的访问时，就要考虑重新设计以减少这种耦合；</li></ul><h3 id="可变性最小化"><a href="#可变性最小化" class="headerlink" title="可变性最小化"></a>可变性最小化</h3><p>不可变类是指其实例不能被修改的类。每个实例中包含的所有信息都必须在创建该实例时提供，并在对象的整个生命周期内固定不变。不可变类好处就是简单易用、线程安全、可自由共享而不容易出错。Java 平台类库中包含许多不可变的类，比如 String、基本类型包装类、BigDecimal 等。</p><p>为了使类成为不可变，要遵循下面五条规则：</p><ul><li>声明所有的域都是私有的</li><li>声明所有的域都是 final 的<ul><li>如果一个指向新创建实例的引用在缺乏同步机制的情况下，从一个线程被传递到另一个线程，就必须确保正确的行为</li></ul></li><li>不提供任何会修改对象状态的方法</li><li>保证类不会被扩展（防止子类化，类声明为 final）<ul><li>防止粗心或者恶意的子类假装对象的状态已经改变，从而破坏该类的不可变行为</li></ul></li><li>确保对任何可变组件的互斥访问<ul><li>如果类具有指向可变对象的域，则必须确保该类的客户端无法获得指向这些对象的引用。并且，永远不要用客户端提供的对象引用来初始化这样的域，也不要从任何访问方法中返回该对象引用。在构造器、访问方法和 readObject 方法中使用保护性拷贝技术</li></ul></li></ul><p>可变性最小化的一些建议：</p><ul><li>除非有很好的理由要让类成为可变的类，否则它就应该是不可变的；</li><li>如果类不能被做成不可变的，仍然应该尽可能地限制它的可变性；</li><li>除非有令人信服的理由要使域变成非 final 的，否则要使每个域都是 private final 的；</li><li>构造器应该创建完全初始化的对象，并建立起所有的约束关系；</li></ul><h1 id="质量如何保证"><a href="#质量如何保证" class="headerlink" title="质量如何保证"></a>质量如何保证</h1><h2 id="测试驱动开发"><a href="#测试驱动开发" class="headerlink" title="测试驱动开发"></a>测试驱动开发</h2><p>测试驱动开发（TDD）要求以测试作为开发过程的中心，要求在编写任何代码之前，首先编写用于产码行为的测试，而编写的代码又要以使测试通过为目标。TDD 要求测试可以完全自动化地运行，并在对代码重构前后必须运行测试。</p><p>TDD 的最终目标是整洁可用的代码（clean code that works）。大多数的开发者大部分时间无法得到整洁可用的代码。办法是分而治之。首先解决目标中的“可用”问题，然后再解决“代码的整洁”问题。这与体系结构驱动（architecture-driven）的开发相反。</p><p>采用 TDD 另一个好处就是让我们拥有一套伴随代码产生的详尽的自动化测试集。将来无论出于任何原因（需求、重构、性能改进）需要对代码进行维护时，在这套测试集的驱动下工作，我们代码将会一直是健壮的。</p><h2 id="TDD-的开发周期"><a href="#TDD-的开发周期" class="headerlink" title="TDD 的开发周期"></a>TDD 的开发周期</h2><p><img src="https://cdn.jsdelivr.net/gh/g-ydg/images/blog/FibrgbZ4-qXo962kPEWWAFx7eE78.png"></p><p>添加一个测试 -&gt; 运行所有测试并检查测试结果 -&gt; 编写代码以通过测试 -&gt; 运行所有测试且全部通过 -&gt; 重构代码，以消除重复设计，优化设计结构</p><h2 id="两个基本的原则"><a href="#两个基本的原则" class="headerlink" title="两个基本的原则"></a>两个基本的原则</h2><ul><li>仅在测试失败时才编写代码并且只编写刚好使测试通过的代码</li><li>编写下一个测试之前消除现有的重复设计，优化设计结构</li></ul><p>关注点分离是这两条规则隐含的另一个非常重要的原则。其表达的含义指在编码阶段先达到代码“可用”的目标，在重构阶段再追求“整洁”目标，每次只关注一件事！</p><h2 id="分层测试点"><a href="#分层测试点" class="headerlink" title="分层测试点"></a>分层测试点</h2><table><thead><tr><th>测试类型</th><th>目标</th><th>测试和结果判定</th></tr></thead><tbody><tr><td>Dao 测试</td><td>验证 mybatis-config、mapper、handler 的正确性</td><td>基于内存数据库<br>可以使用 assert 验证</td></tr><tr><td>Adapter 测试</td><td>验证外部依赖交互正确<br>验证 converter 正确</td><td>依赖外部环境<br>正确性依赖人工判读</td></tr><tr><td>Repository 测试</td><td>验证内部计算、转换逻辑</td><td>可 mock 外部依赖<br>可以使用 assert 验证</td></tr><tr><td>biz 层测试</td><td>验证内部业务逻辑</td><td>尽可能隔离所有外部依赖<br>需要多个测试，每个测试验证一个场景或分支<br>使用 assert 验证，不依赖人工判断</td></tr><tr><td>Application 层测试</td><td>验证入口参数处理正确<br>验证系统内链路无阻塞</td><td>可以隔离外部依赖<br>场景覆盖通过参数控制<br>可使用单步调试观察代码执行走向<br>不验证详细逻辑</td></tr></tbody></table><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>重构-改善既有代码的设计</li><li>设计模式</li><li>Effective Java</li><li>敏捷软件开发与设计的最佳实践</li><li>实现模式</li><li>测试驱动开发</li></ul></div><div class="article-footer"><blockquote class="mt-2x"><ul class="post-copyright list-unstyled"><li class="post-copyright-link hidden-xs"><strong>本文链接：</strong> <a href="https://g-ydg.github.io/2021/05/18/%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84%E6%8A%80%E5%B7%A7/" title="常见代码重构技巧" target="_blank" rel="external">https://g-ydg.github.io/2021/05/18/常见代码重构技巧/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！</li></ul></blockquote></div></article><section id="comments"></section></div><nav class="bar bar-footer clearfix" data-stick-bottom><div class="bar-inner"><ul class="pager pull-left"><li class="prev"><a href="/2021/06/10/%E6%8F%90%E9%AB%98PHP%E8%84%9A%E6%9C%AC%E6%80%A7%E8%83%BD%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/" title="提高PHP脚本性能的小技巧"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a></li><li class="next"><a href="/2021/04/29/PHP%E7%9A%84%E7%94%9F%E6%88%90%E5%99%A8%EF%BC%88generator%EF%BC%89/" title="PHP的生成器（generator）"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a></li></ul><button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button><div class="bar-right"><div class="share-component" data-sites="weibo,qq,wechat" data-mobile-sites="weibo,qq,qzone"></div></div></div></nav><div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog"><div class="modal-dialog" role="document"><div class="modal-content donate"><button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button><div class="modal-body"><div class="donate-box"><div class="donate-head"><p>感谢您的支持，我会继续努力的!</p></div><div class="tab-content"><div role="tabpanel" class="tab-pane fade active in" id="alipay"><div class="donate-payimg"><img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫"></div><p class="text-muted mv">扫码打赏，你说多少就多少</p><p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦</p></div><div role="tabpanel" class="tab-pane fade" id="wechatpay"><div class="donate-payimg"><img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫"></div><p class="text-muted mv">扫码打赏，你说多少就多少</p><p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p></div></div><div class="donate-footer"><ul class="nav nav-tabs nav-justified" role="tablist"><li role="presentation" class="active"><a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a></li><li role="presentation"><a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a></li></ul></div></div></div></div></div></div></main><footer class="footer" itemscope itemtype="http://schema.org/WPFooter"><ul class="social-links"><li><a href="https://github.com/g-ydg" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li><li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li></ul><div class="copyright">&copy; 2026 Ydd<div class="publishby">Theme by <a href="https://github.com/cofess" target="_blank">cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.</div></div></footer><script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script><script>window.jQuery||document.write('<script src="js/jquery.min.js"><\/script>')</script><script src="/js/plugin.min.js"></script><script src="/js/application.js"></script><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"分类",TAGS:"标签",UNTITLED:"(未命名)"},ROOT_URL:"/",CONTENT_URL:"/content.json"}</script><script src="/js/insight.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>